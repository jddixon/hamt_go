<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>hamt_go</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/normalize.css" />
  <link rel="stylesheet" type="text/css" href="css/ghp.css" />
</head>
<body>
<div class="content">
<h1>hamt_go</h1>

<p>Go implementation of the HAMT data structure.</p>

<p>A Hash Array Mapped Trie (<a href="http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf">HAMT</a>)
provides fast and memory-efficient access to large amounts of data held
in memory.  Values are stored by <em>key</em>.  All HAMT keys are mapped into
fixed length unsigned integers. In this implementation these are 64 bits
long, Go <code>uint64</code>s..  The <em>value</em> may be of any type but typically is a
<em>pointer</em> to a data structure of interest.</p>

<p>The HAMT trie is essentially a prefix trie.  At each level
there is a table with <code>2^w</code> slots.  The <code>w</code> bits are construed as
an index into that table.  The current implementation allows values of
<code>4, 5, 6, 7,</code> or <code>8</code> for <code>w</code>.  Preliminary performance tests indicate
that <code>w=5</code> is optimal.  That is, a table with 32 slots gives the best
performance.</p>

<p>Whereas a normal hash table would be quite large and might
require periodic expensive resizing, the HAMT data structure is roughly
as fast as a hash table, but starts small and consumes more memory only
as needed.</p>

<h2>Limitations</h2>

<ul>
<li><p>This code is not thread-safe.  That is, using code must provide any
necessary locking.</p></li>

<li><p>the HAMT algorithm depends upon bit-counting.  On modern Intel and AMD
processors this
can be done using a specific machine-language instruction, POPCNT.  The current
implementation of hamt_go emulates this in software using the
<a href="http://en.wikipedia.org/wiki/SWAR">SWAR</a> algorithm,  The emulation code is on the order of ten times
slower than the machine instruction.<br />
<em>In practice POPCNT emulation might slow down accesses by something like 10%,
because the emulation code simply is not run all that often.</em></p></li>
</ul>

<h2>Project Status</h2>

<p>The code works and is reasonably well-tested.
<code>Insert</code>, <code>Find</code>, and <code>Delete</code> operations, while not yet thoroughly optimized,
take on the order of 1.5 microseconds each on a lightly-loaded server
(just under 3us each to insert a million values and verify that the
value can be found using the key.</p>

<h2>References</h2>

<p><a href="http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf">Bagwell, &ldquo;Ideal Hash Trees&rdquo;</a>  (2001 PDF)</p>

<p><a href="http://en.wikipedia.org/wiki/Hash_array_mapped_trie">Wikipeida, &ldquo;Hash array mapped trie&rdquo;</a></p>

<p><a href="http://en.wikipedia.org/wiki/SWAR">Wikipedia, &ldquo;SWAR&rdquo;</a></p>
  <div class="f">
    <hr />
    <div class="license">
      <p><a href="LICENSE.html">LICENSE</a></p>
    </div>
    <div class="project">
      github <a href="https://github.com/jddixon/hamt_go">      <img src="img/GitHub-Mark-32px.png" 
        alt="link to project"  
        style="display: inline-block; margin-left: 0 auto; margin-right: 0 auto">
       </a> project
    </div>
    <div class="logo" >
      <a href="http://www.xlattice.org">
      <img src="img/xlattice-2014.jpg" alt="the XLattice Project" style="float: right;" >
      </a>
    </div>
  </div>
</div>
</body>
</html>
