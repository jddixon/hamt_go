<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>hamt_go</title>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="css/main.css" />
  <link rel="stylesheet" type="text/css" href="css/normalize.css" />
  <link rel="stylesheet" type="text/css" href="css/ghp.css" />
</head>
<body>
<div class="content">
<h1>hamt_go</h1>

<p>Go implementation of the HAMT data structure.</p>

<p>A Hash Array Mapped Trie (<a href="http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf">HAMT</a>)
provides fast and memory-efficient access to large amounts of data held
in memory.  In this
particular implementation there are 32- and 64-bit versions
of the code, HAMT32 and HAMT64 respectively.  HAMT associates keys and values.  The <strong>key</strong> is
something that produces a 32- or 64-bit unsigned integer, as appropriate.
The value is completely arbitrary, but typically is a pointer to a data
structure of interest.</p>

<p>HAMT keys have a <code>Hashcode</code> function that produces a fixed length integer
that is treated as a sequence of bits.  This is used to navigate and
modify the in-memory trie structure.  At each level in the trie there is
a table of <code>2^5</code> or <code>2^6</code> slots.  Each slot contains either a nil pointer
or a pointer to a value or a pointer to a lower-level table.  So a HAMT32
table is rougly <code>32 * 4 = 128</code> bytes in size, and a HAMT64 table about
<code>64 * 8 = 512</code> bytes.  Whereas a normal hash table would be quite large and
require periodic expensive resizing, the HAMT data structure is roughly
as fast as a hash table, but starts small and consumes more memory only
as needed.</p>

<h2>Limitations</h2>

<ul>
<li><p>This code is not thread-safe.  That is, using code must provide any
necessary locking.</p></li>

<li><p>HAMT depends upon bit-counting.  On modern Intel and AMD processors this
can be done using a specific machine-language instruction, POPCNT.  The current
implementation of hamt_go emulates this in software using the
<a href="http://en.wikipedia.org/wiki/SWAR">SWAR</a> algorithm,  The emulation code is on the order of ten times
slower than the machine instruction.</p></li>
</ul>

<p>In practice POPCNT emulation might slow down accesses by something like 10%,
because the emulation code simply is not run all that often.</p>

<h2>Project Status</h2>

<p>Both 32- and 64-bit versions of the code work and are reasonably well-tested.
Insert, find, and delete operations, while not yet thoroughly optimized,
take on the order of 10 microseconds each on a lightly-loaded server.</p>

<h2>References</h2>

<p><a href="http://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf">Bagwell, &ldquo;Ideal Hash Trees&rdquo;</a>  (2001 PDF)</p>

<p><a href="http://en.wikipedia.org/wiki/Hash_array_mapped_trie">Wikipeida, &ldquo;Hash array mapped trie&rdquo;</a></p>

<p><a href="http://en.wikipedia.org/wiki/SWAR">Wikipedia, &ldquo;SWAR&rdquo;</a></p>
  <div class="f">
    <hr />
    <div class="license">
      <p><a href="LICENSE.html">LICENSE</a></p>
    </div>
    <div class="project">
      github <a href="https://github.com/jddixon/hamt_go">      <img src="img/GitHub-Mark-32px.png" 
        alt="link to project"  
        style="display: inline-block; margin-left: 0 auto; margin-right: 0 auto">
       </a> project
    </div>
    <div class="logo" >
      <a href="http://www.xlattice.org">
      <img src="img/xlattice-2014.jpg" alt="the XLattice Project" style="float: right;" >
      </a>
    </div>
  </div>
</div>
</body>
</html>
